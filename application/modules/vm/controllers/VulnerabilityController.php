<?php
/**
 * Copyright (c) 2010 Endeavor Systems, Inc.
 *
 * This file is part of OpenFISMA.
 *
 * OpenFISMA is free software: you can redistribute it and/or modify it under the terms of the GNU General Public 
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OpenFISMA is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along with OpenFISMA.  If not, see 
 * {@link http://www.gnu.org/licenses/}.
 */

/**
 * Controller for Vulnerabilities
 *
 * @author     Andrew Reeves <andrew.reeves@endeavorsystems.com>
 * @copyright  (c) Endeavor Systems, Inc. 2010 {@link http://www.endeavorsystems.com}
 * @license    http://www.openfisma.org/content/license GPLv3
 * @package    Controller
 */
class Vm_VulnerabilityController extends Fisma_Zend_Controller_Action_Object
{
    /**
     * The main name of the model.
     * 
     * This model is the main subject which the controller operates on.
     * 
     * @var string
     */
    protected $_modelName = 'Vulnerability';

    /**
     * Invokes a contract with Fisma_Zend_Controller_Action_Object regarding privileges
     * 
     * @var string
     * @link http://jira.openfisma.org/browse/OFJ-24
     */
    protected $_organizations = '*';

    /** 
     * Import scan results via a plug-in
     * 
     * @return void
     */
    public function pluginAction()
    {       
        $this->_acl->requirePrivilegeForClass('create', 'Vulnerability');

        // Load the finding plugin form
        $uploadForm = Fisma_Zend_Form_Manager::loadForm('vulnerability_upload');
        $uploadForm = Fisma_Zend_Form_Manager::prepareForm($uploadForm);
        $uploadForm->setAttrib('id', 'injectionForm');

        // Populate the drop menu options
        $networks = Doctrine::getTable('Network')->findAll()->toArray();
        $networkList = array();
        foreach ($networks as $network) {
            $networkList[$network['id']] = $network['nickname'] . ' - ' . $network['name'];
        }
        $uploadForm->network->addMultiOption('', '');
        $uploadForm->network->addMultiOptions($networkList);
        
        // Configure the file select
        $uploadForm->setAttrib('enctype', 'multipart/form-data');
        $uploadForm->selectFile->setDestination(Fisma::getPath('data') . '/uploads/scanreports');

        // Setup the view
        $this->view->assign('uploadForm', $uploadForm);

        // Handle the file upload, if necessary
        $fileReceived = false;
        $postValues = $this->_request->getPost();
        if ($postValues) {
            if ($uploadForm->isValid($postValues) && $fileReceived = $uploadForm->selectFile->receive()) {
                $filePath = $uploadForm->selectFile->getTransferAdapter()->getFileName('selectFile');
                $values = $uploadForm->getValues();
                $values['filepath'] = $filePath;
                // Execute the plugin with the received file
                try {
                    $plugin = Fisma_Inject_Factory::create(NULL, $values);

                    // get original file name
                    $originalName = pathinfo(basename($filePath), PATHINFO_FILENAME);
                    // get current time and set to a format like '_2009-05-04_11_22_02'
                    $ts = time();
                    $dateTime = date('_Y-m-d_H_i_s', $ts);
                    // define new file name
                    $newName = str_replace($originalName, $originalName . $dateTime, basename($filePath));
                    // organize upload data
                    $upload = new Upload();
                    $upload->userId = $this->_me->id;
                    $upload->fileName = $newName;
                    $upload->save();
                    
                    // parse the file
                    $plugin->parse($upload->id);
                    // rename the file by ts
                    rename($filePath, dirname($filePath) . '/' . $newName);

                    $message = "Your scan report was successfully uploaded.<br>"
                             . "{$plugin->created} vulnerabilities were created.<br>"
                             //. "{$plugin->reviewed} vulnerabilities need review.<br>"
                             . "{$plugin->deleted} vulnerabilities were suppressed.";
                    $this->view->priorityMessenger($message, 'notice');
                } catch (Fisma_Zend_Exception_InvalidFileFormat $e) {
                    $this->view->priorityMessenger($e->getMessage(), 'warning');
                }
            } else {
                $errorString = Fisma_Zend_Form_Manager::getErrors($uploadForm);

                if (!$fileReceived) {
                    $errorString .= "File not received<br>";
                }

                // Error message
                $this->view->priorityMessenger("Scan upload failed:<br>$errorString", 'warning');
            }
            // This is a hack to make the submit button work with YUI:
            /** @yui */ $uploadForm->upload->setValue('Upload');
            $this->render(); // Not sure why this view doesn't auto-render?? It doesn't render when the POST is set.
        }
    }

    /**
     * Default pagination parameters
     * 
     * @var array
     */
    protected $_paging = array(
        'startIndex' => 0,
        'count' => 20
    );
    
    /**
     * The preDispatch hook is used to split off poam modify actions, mitigation approval actions, and evidence
     * approval actions into separate controller actions.
     * 
     * @return void
     */
    public function preDispatch() 
    {
        parent::preDispatch();

        $this->_organizations = $this->_me->getOrganizationsByPrivilege('finding', 'read');

        $request = $this->getRequest();
        $this->_paging['startIndex'] = $request->getParam('startIndex', 0);
    }
              
    /**
    * Create the additional PDF, XLS and RSS contexts for this class.
    * 
    * @return void
    */
    public function init()
    {
        $contextSwitch = $this->_helper->fismaContextSwitch();
        $contextSwitch->addActionContext('search2', array('xls', 'pdf'));

        if ('search2' == $this->getRequest()->getActionName()) {
           $contextSwitch->setAutoDisableLayout(true);
        }
        
        $contextSwitch->initContext();

        parent::init();
    }
    
    /**
     * Default action.
     * 
     * It combines the searching and summary into one page.
     * 
     * @return void
     */
    public function indexAction()
    {
        $this->_acl->requirePrivilegeForClass('read', 'Vulnerability');
    }

    /**
     * Parse and translate the URL to criterias
     * which can be used by searchBoxAction method and searchAction method.
     *
     * @return array The criterias dealt
     */
    private function _parseCriteria()
    {
        $params = array('responsibleOrganizationId' => 0, 'sourceId' => 0, 'type' => '',
                        'status' => '', 'ids' => '', 'assetOwner' => 0,
                        'estDateBegin' => '', 'estDateEnd' => '',
                        'createdDateBegin' => '', 'createdDateEnd' => '',
                        'ontime' => '', 'sortby' => '', 'dir'=> '', 'keywords' => '', 'expanded' => null);
        $req = $this->getRequest();
        $tmp = $req->getParams();
        foreach ($params as $k => &$v) {
            if (isset($tmp[$k])) {
                $v = $tmp[$k];
            }
        }
        if (is_numeric($params['responsibleOrganizationId'])) {
            $params['responsibleOrganizationId'] = $params['responsibleOrganizationId'];
        }
        if (is_numeric($params['sourceId'])) {
            $params['sourceId'] = $params['sourceId'];
        }
        if (is_numeric($params['assetOwner'])) {
            $params['assetOwner'] = $params['assetOwner'];
        }

        $message = '';
        if (!empty($params['estDateBegin']) && Zend_Date::isDate($params['estDateBegin'], 'Y-m-d')) {
            $params['estDateBegin'] = new Zend_Date($params['estDateBegin'], 'Y-m-d');
        } else if (!empty($params['estDateBegin'])) {
            $message = 'Estimated Completion Date From: ' . $params['estDateBegin']
                     . ' is not of the format YYYY-MM-DD.<br>';
            $params['estDateBegin'] = '';
        } else {
            $params['estDateBegin'] = '';
        }

        if (!empty($params['estDateEnd']) && Zend_Date::isDate($params['estDateEnd'], 'Y-m-d')) {
            $params['estDateEnd'] = new Zend_Date($params['estDateEnd'], 'Y-m-d');
        } else if (!empty($params['estDateEnd'])) {
            $message = $message . 'Estimated Completion Date To: ' . $params['estDateEnd']
                     . ' is not of the format YYYY-MM-DD.<br>';
            $params['estDateEnd'] = '';
        } else {
            $params['estDateEnd'] = '';
        }

        if (!empty($params['createdDateBegin']) && Zend_Date::isDate($params['createdDateBegin'], 'Y-m-d')) {
            $params['createdDateBegin'] = new Zend_Date($params['createdDateBegin'], 'Y-m-d');
        } else if (!empty($params['createdDateBegin'])) {
            $message = $message . 'Date Created From: ' . $params['createdDateBegin']
                     . ' is not of the format YYYY-MM-DD.<br>';
            $params['createdDateBegin'] = '';
        } else {
            $params['createdDateBegin'] = '';
        }

        if (!empty($params['createdDateEnd']) && Zend_Date::isDate($params['createdDateEnd'], 'Y-m-d')) {
            $params['createdDateEnd'] = new Zend_Date($params['createdDateEnd'], 'Y-m-d');
        } else if (!empty($params['createdDateEnd'])) {
            $message = $message . 'Date Created To: ' . $params['createdDateEnd']
                     . 'is not of the format YYYY-MM-DD.';
            $params['createdDateEnd'] = '';
        } else {
            $params['createdDateEnd'] = '';
        }

        if (!empty($message)) {
            $this->view->priorityMessenger($message, 'warning');
        }

        return $params;
    }
    
    /**
     * Get the columns(title) which were displayed on page, PDF, Excel
     * 
     * @return array The two dimension array which includes column id in index and the label, sortable and 
     * hidden of the column in value.
     */
    private function _getColumns()
    {
        // Set up the data for the columns in the search results table
        $me = Doctrine::getTable('User')->find($this->_me->id);
        
        try {
            $cookie = Fisma_Cookie::get($_COOKIE, 'search_columns_pref');
            $visibleColumns = $cookie;
        } catch(Fisma_Zend_Exception $e) {
            if (empty($me->searchColumnsPref)) {
                $me->searchColumnsPref = $visibleColumns = 66037;
                $me->save();
            } else {
                $visibleColumns = $me->searchColumnsPref;
            }
        }

        $columns = array(
            'id' => array('label' => 'ID', 
                          'sortable' => true, 
                          'hidden' => ($visibleColumns & 1) == 0),
            'sourceNickname' => array('label' => 'Source', 
                                       'sortable' => true, 
                                       'hidden' => ($visibleColumns & (1 << 1)) == 0,
                                       'formatter' => 'text'),
            'systemNickname' => array('label' => 'System', 
                                       'sortable' => true, 
                                       'hidden' => ($visibleColumns & (1 << 2)) == 0,
                                       'formatter' => 'text'),
            'assetName' => array('label' => 'Asset', 
                                  'sortable' => true, 
                                  'hidden' => ($visibleColumns & (1 << 3)) == 0,
                                  'formatter' => 'text'),
            'type' => array('label' => 'Type', 
                            'sortable' => true, 
                            'hidden' => ($visibleColumns & (1 << 4)) == 0,
                            'formatter' => 'text'),
            'status' => array('label' => 'Status', 
                              'sortable' => true, 
                              'hidden' => ($visibleColumns & (1 << 5)) == 0,
                              'formatter' => 'text'),
            'duetime' => array('label' => 'On Time?', 
                               'sortable' => false, 
                               'hidden' => ($visibleColumns & (1 << 6)) == 0,
                               'formatter' => 'text'),
            'description' => array('label' => 'Description', 
                                    'sortable' => false, 
                                    'hidden' => ($visibleColumns & (1 << 7)) == 0),
            'recommendation' => array('label' => 'Recommendation', 
                                        'sortable' => false, 
                                        'hidden' => ($visibleColumns & (1 << 8)) == 0),
            'mitigationStrategy' => array('label' => 'Course of Action', 
                                      'sortable' => false, 
                                      'hidden' => ($visibleColumns & (1 << 9)) == 0),
            'securityControl' => array('label' => 'Security Control', 
                                'sortable' => true, 
                                'hidden' => ($visibleColumns & (1 << 10)) == 0,
                                'formatter' => 'text'),
            'threatLevel' => array('label' => 'Threat Level', 
                                    'sortable' => true, 
                                    'hidden' => ($visibleColumns & (1 << 11)) == 0,
                                    'formatter' => 'text'),
            'threat' => array('label' => 'Threat Description', 
                                     'sortable' => false, 
                                     'hidden' => ($visibleColumns & (1 << 12)) == 0),
            'countermeasuresEffectiveness' => array('label' => 'Countermeasure Effectiveness', 
                                              'sortable' => true, 
                                              'hidden' => ($visibleColumns & (1 << 13)) == 0,
                                              'formatter' => 'text'),
            'countermeasures' => array('label' => 'Countermeasure Description', 
                                'sortable' => false, 
                                'hidden' => ($visibleColumns & (1 << 14)) == 0),
            'attachments' => array('label' => 'Attachments', 
                                   'sortable' => false, 
                                   'hidden' => ($visibleColumns & (1 << 15)) == 0),
            'currentEcd' => array('label' => 'Expected Completion Date', 
                                           'sortable' => true, 
                                           'hidden' => ($visibleColumns & (1 << 16)) == 0,
                                           'formatter' => 'text')
        );
        return $columns;
    }
    
    /**
     * View details of a finding object
     * 
     * @return void
     */
    public function viewAction()
    {
        $id = $this->_request->getParam('id');

        $vulnerability = $this->_getVulnerability($id);
        $this->view->vulnerability = $vulnerability;
        
        $this->_acl->requirePrivilegeForObject('read', $vulnerability);

        // Load state transition buttons
        $stateTransitionForm = Fisma_Zend_Form_Manager::loadForm('state_transitions');
        
        $stateTransitionForm->getElement('id')->setValue($id);
        
        $stateTransitionForm->setDecorators(
            array(
                'FormElements',
                array('HtmlTag', array('tag' => 'span')),
                'Form'
            )
        );
            
        $stateTransitionForm->setElementDecorators(array('ViewHelper', 'RenderSelf'));

        // Disable buttons which are disallowed based on current state or user role
        if (!$vulnerability->isValidStateTransition($vulnerability->status, 'AR') ||
            !$this->_acl->hasPrivilegeForObject('accept_risk', $vulnerability)) {
            
            $stateTransitionForm->getElement('acceptRisk')->readOnly = true;
        }

        if (!$vulnerability->isValidStateTransition($vulnerability->status, 'FP') ||
            !$this->_acl->hasPrivilegeForObject('false_positive', $vulnerability)) {
            
            $stateTransitionForm->getElement('falsePositive')->readOnly = true;
        }

        if (!$vulnerability->isValidStateTransition($vulnerability->status, 'CLOSED') ||
            !$this->_acl->hasPrivilegeForObject('close', $vulnerability)) {
            
            $stateTransitionForm->getElement('close')->readOnly = true;
        }
        
        $this->view->stateTransitionForm = $stateTransitionForm;

        // Put a span around the comment count so that it can be updated from Javascript
        $commentCount = '<span id=\'findingCommentsCount\'>' . $vulnerability->getComments()->count() . '</span>';

        $tabView = new Fisma_Yui_TabView('VulnerabilityView', $id);

        $tabView->addTab("Vulnerability $id", "/vm/vulnerability/vulnerability/id/$id");
        $tabView->addTab("Asset", "/vm/vulnerability/asset/id/$id");
        $tabView->addTab("Comments ($commentCount)", "/vm/vulnerability/comments/id/$id");
        $tabView->addTab("Audit Log", "/vm/vulnerability/audit-log/id/$id");

        $this->view->tabView = $tabView;
    }

    /**
     * Add a comment to a specified vulnerability
     */
    public function addCommentAction()
    {
        $id = $this->getRequest()->getParam('id');
        $vulnerability = Doctrine::getTable('Vulnerability')->find($id);

        $this->_acl->requirePrivilegeForObject('update', $vulnerability);
        
        $comment = $this->getRequest()->getParam('comment');
        
        if ('' != trim(strip_tags($comment))) {
            $vulnerability->getComments()->addComment($comment);
        } else {
            $this->view->priorityMessenger('Comment field is blank', 'warning');
        }
        
        $this->_redirect("/vm/vulnerability/view/id/$id");
    }

    /**
     * Display comments for this vulnerability
     */
    public function commentsAction()
    {
        $id = $this->_request->getParam('id');
        $this->view->assign('id', $id);
        $vulnerability = Doctrine::getTable('Vulnerability')->find($id);

        $this->_acl->requirePrivilegeForObject('read', $vulnerability);

        $comments = $vulnerability->getComments()->fetch(Doctrine::HYDRATE_ARRAY);

        $commentButton = new Fisma_Yui_Form_Button(
            'commentButton', 
            array(
                'label' => 'Add Comment', 
                'onClickFunction' => 'Fisma.Commentable.showPanel',
                'onClickArgument' => array(
                    'id' => $id,
                    'type' => 'Vulnerability',
                    'callback' => array(
                        'object' => 'Vulnerability',
                        'method' => 'commentCallback'
                    )
                )
            )
        );

        if (!$this->_acl->hasPrivilegeForObject('comment', $vulnerability)) {
            $commentButton->readOnly = true;
        }

        $this->view->commentButton = $commentButton;
        $this->view->comments = $comments;
        $this->_helper->layout->setLayout('ajax');
    }
    
    /**
     * Modify the vulnerability
     * 
     * @return void
     */
    public function modifyAction()
    {
        // ACL for finding objects is handled inside the finding listener, because it has to do some
        // very fine-grained error checking
        
        $id = $this->_request->getParam('id');
        $findingData = $this->_request->getPost('finding', array());

        $this->_forward('view', null, null, array('id' => $id));

        $finding = $this->_getFinding($id);
        
        try {
            Doctrine_Manager::connection()->beginTransaction();
            $finding->merge($findingData);
            $finding->save();
            Doctrine_Manager::connection()->commit();
        } catch (Fisma_Zend_Exception_User $e) {
            $this->view->priorityMessenger($e->getMessage(), 'warning');
        } catch (Exception $e) {
            Doctrine_Manager::connection()->rollback();
            $message = "Error: Unable to update finding. ";
            if (Fisma::debug()) {
                $message .= $e->getMessage();
            }
            $model = 'warning';
            $this->view->priorityMessenger($message, $model);
        }
    }

    /**
     * Display basic data about the vulnerability
     * 
     * @return void
     */
    function vulnerabilityAction() 
    {
        $this->_viewVulnerability();
        $this->view->keywords = $this->_request->getParam('keywords');
        $this->_helper->layout->setLayout('ajax');
    }

    /**
     * Display the audit log associated with a finding
     * 
     * @return void
     */
    function auditLogAction() 
    {
        $this->_viewVulnerability();
        $this->_helper->layout->setLayout('ajax');
        
        $logs = $this->view->vulnerability->getAuditLog()->fetch(Doctrine::HYDRATE_SCALAR);
        
        // Convert log messages from plain text to HTML
        foreach ($logs as &$log) {
            $log['o_message'] = $this->view->textToHtml($log['o_message']);
        }

        $this->view->columns = array('Timestamp', 'User', 'Message');
        $this->view->rows = $logs;
    }
    
    /**
     * Real searching worker, to return searching results for page, PDF, Excel
     * 
     * @return void
     */
    public function search2Action() 
    {
        $this->_acl->requirePrivilegeForClass('read', 'Finding');
        
        /* @todo A hack to translate column names in the data table to column names
         * which can be sorted... this could probably be done in a much better way.
         */
        $columnMap = array(
            'sourceNickname' => 's.nickname',
            'systemNickname' => 'ro.nickname',
            'assetName' => 'a.name',
            'securityControl' => 'sc.code'
        );
        
        $tableData = array(
            'recordsReturned' => 0,
            'totalRecords' => $total = 0,
            'startIndex' => $this->_paging['startIndex'],
            'sort' => null,
            'dir' => 'asc',
            'pageSize' => $this->_paging['count'],
            'records' => array()
        );
        
        // JSON requests are handled differently from PDF and XLS requests, so we need
        // to determine which request type this is.
        $format = $this->_request->getParam('format');
        
        $params = $this->_parseCriteria();
        
        if (in_array($params['sortby'], array_keys($columnMap))) {
            $params['sortby'] = $columnMap[$params['sortby']];
        } elseif (in_array($params['sortby'], array_keys($this->_getColumns()))) {
            $params['sortby'] = 'f.' . $params['sortby'];
        } else {
            $params['sortby'] = 'f.id';
        }
        
        if (strtoupper($params['dir']) == 'DESC') {
            $params['dir'] = 'DESC';
        } else {
            $params['dir'] = 'ASC';
        }
        
        if (!empty($params['status'])) {
            $now = new Zend_Date();
            switch ($params['status']) {
                case 'TOTAL': $params['status'] = array('NEW', 'DRAFT', 'MSA', 'EN', 'EA', 'CLOSED');
                    break;
                case 'NOT-CLOSED': $params['status'] = array('NEW', 'DRAFT', 'MSA', 'EN', 'EA');
                    break;
                case 'NOUP-30': $params['status'] = array('DRAFT', 'MSA', 'EN', 'EA');
                     $params['modify_ts'] = $now->subDay(30);
                    break;
                case 'NOUP-60':
                     $params['status'] = array('DRAFT', 'MSA', 'EN', 'EA');
                     $params['modify_ts'] = $now->subDay(60);
                    break;
                case 'NOUP-90':
                     $params['status'] = array('DRAFT', 'MSA', 'EN', 'EA');
                     $params['modify_ts'] = $now->subDay(90);
                    break;
                case 'NEW':  case 'DRAFT':  case 'EN': case 'CLOSED': default : 
                    break;
            }
        }
        if ($params['ids']) {
            $params['ids'] = explode(',', $params['ids']);
        }
        // Use Zend Lucene to find all POAM ids which match the keyword query
        if (!empty($params['keywords'])) {
            if (preg_match('/^[0-9, ]+$/', $params['keywords'])) {
                // if the query contains only numbers and commas and whitespace, then interpret it as a list of 
                // ids to search for
                $params['ids'] = explode(',', $params['keywords']);
            } else {
                // Otherwise, interpret it as a lucene query
                try {
                    $index = new Fisma_Index('Finding');
                    $poamIds = $index->findIds($params['keywords']);
                    $tableData['highlightWords'] = $index->getHighlightWords();
                } catch (Zend_Search_Lucene_Exception $e) {
                    $tableData['exception'] = $e->getMessage();
                }
                // Even though it isn't rendered in the view, the highlight words need to be exported to the view...
                // due the stupid design of this class
                $this->view->keywords = $tableData['highlightWords'];
                // Merge keyword results with filter results
                if ($params['ids'] && $poamIds) {
                    $params['ids'] = array_intersect($poamIds, $params['ids']);
                    if (!$params['ids']) {
                        $list = array();
                    }
                } elseif ($poamIds) {
                    $params['ids'] = $poamIds;
                } else {
                    $list = array();
                }
            }
        }
        
        if (!isset($list)) {
            $list = $this->_getResults($params, $format, $total);
        }
        
        if ($format == 'pdf' || $format == 'xls') {
            $this->view->columnPreference = Doctrine::getTable('User')
                                            ->find($this->_me->id)
                                            ->searchColumnsPref;
            $this->view->columns = $this->_getColumns();
            /**
             * @todo to support free sorting in exporting PDF and Excel like in datatable
             */
            $this->view->list = $list;
        } else {
            $this->_helper->contextSwitch()
                          ->addActionContext('search2', 'json')
                          ->initContext();
            $tableData['recordsReturned'] = count($list);
            $tableData['totalRecords'] = $total;
            $tableData['sort'] = $params['sortby'];
            $tableData['dir'] = $params['dir'];
            $tableData['records'] = $list;
            $this->view->assign('findings', $tableData);
        }
    }
    
    /**
     * Analyze the criterias and merge the DQL query for getting results
     * 
     * @param array $params The specified filter criterias
     * @param string $format The specified output format which is json or xls or pdf
     * @param int $total The total number of found rows
     * @return array $list The corresponding results
     */
    private function _getResults($params, $format, &$total)
    {
        $list = array();
        $q = Doctrine_Query::create()
            ->select()
            ->from('Finding f')
            ->leftJoin('f.ResponsibleOrganization ro')
            ->leftJoin('f.Source s')
            ->leftJoin('f.SecurityControl sc')
            ->leftJoin('f.CurrentEvaluation ce')
            ->leftJoin('ro.System ros')
            ->whereIn(
                'f.responsibleOrganizationId', 
                $this->_me->getOrganizationsByPrivilege('finding', 'read')->toKeyValueArray('id', 'id')
            )
            ->andWhere('ro.orgType <> ? OR ros.sdlcPhase <> ?', array('system', 'disposal'))
            ->orderBy($params['sortby'] . ' ' . $params['dir']);

        foreach ($params as $k => $v) {
            if ($v) {
                if ($k == 'estDateBegin') {
                    $v = $v->toString('Y-m-d H:i:s');
                    $q->andWhere("f.currentEcd > ?", $v);
                } elseif ($k == 'estDateEnd') {
                    $v = $v->addDay(1);
                    $v = $v->toString('Y-m-d H:i:s');
                    $q->andWhere("f.currentEcd < ?", $v);
                } elseif ($k == 'createdDateBegin') {
                    $v = $v->toString('Y-m-d H:i:s');
                    $q->andWhere("f.createdTs > ?", $v);
                } elseif ($k == 'createdDateEnd') {
                    $v = $v->addDay(1);
                    $v = $v->toString('Y-m-d H:i:s');
                    $q->andWhere("f.createdTs < ?", $v);
                } elseif ($k == 'status') {
                    if (is_array($v)) {
                        $q->andWhereIn("f.status", $v);
                    } elseif (in_array($v, array('NEW', 'DRAFT', 'EN', 'CLOSED'))) {
                        $q->andWhere("f.status = ?", $v);
                    } else {
                        $q->andWhere("ce.nickname = ?", $v);
                    }
                } elseif ($k == 'modify_ts') {
                    $v = $v->toString('Y-m-d H:i:s');
                    $q->andWhere("f.modifiedTs < ?", $v);
                } elseif ($k == 'ontime') {
                    if ($v == 'ontime') {
                        $q->andWhere('DATEDIFF(NOW(), f.nextDueDate) <= 0');
                    } else {
                        $q->andWhere('DATEDIFF(NOW(), f.nextDueDate) > 0');
                    }
                } elseif ($k == 'ids') {
                    $sqlPart = array();
                    foreach ($v as $id) {
                        if (is_numeric($id)) {
                            $sqlPart[] = 'f.id = ' . $id;
                        }
                    }
                    if (!empty($sqlPart)) {
                        $q->andWhere(implode(' OR ', $sqlPart));
                    }
                } elseif ($k == 'expanded') {
                    // Intentionally falls through. This is a consequence of bad design in this method. The 
                    // 'expanded' variable is not literally added to the query, but is actually just
                    // a modifier for the responsibleOrganizationId parameter.
                    ;
                } elseif ($k == 'responsibleOrganizationId') {
                    if ('false' == $params['expanded']) {
                        $o = Doctrine::getTable('Organization')->find($v);
                        $q->addWhere('ro.lft >= ? AND ro.rgt <= ?', array($o->lft, $o->rgt));
                    } else {
                        $q->addWhere('ro.id = ?', $v);
                    }
                } elseif ($k != 'keywords' && $k != 'dir' && $k != 'sortby') {
                    $q->andWhere("f.$k = ?", $v);
                } 
            }
        }
        if ($format == 'json') {
            $q->limit($this->_paging['count'])->offset($this->_paging['startIndex']);
        }

        // The total number of found rows is appended to the list of finding. 
        $total = $q->count();
        $results = $q->execute();
        
        foreach ($results as $result) {
            $row = array();
            $row['id'] = $result->id;
            $row['type'] = $result->type;
            if ($result->CurrentEvaluation) {
                $row['status'] = $result->CurrentEvaluation->nickname;
            } else {
                $row['status'] = $result->status;
            }
            $row['threatLevel'] = $result->threatLevel;
            if (empty($result->currentEcd) || $result->currentEcd == '0000-00-00') {
                if ($result->currentEcd != '0000-00-00') {
                    $row['currentEcd'] = $result->currentEcd;
                } else {
                    $row['currentEcd'] = '';
                }
            } else {
                $row['currentEcd'] = $result->currentEcd;
            }
            $row['countermeasuresEffectiveness'] = $result->countermeasuresEffectiveness;
            
            $source = $result->Source;
            $row['sourceNickname'] = $source ? $result->Source->nickname : '';
            $responsibleOrganization = $result->ResponsibleOrganization;
            $row['systemNickname'] = $responsibleOrganization ? $result->ResponsibleOrganization->nickname : '';
            $securityControl = $result->SecurityControl;
            $row['securityControl'] = $securityControl ? $result->SecurityControl->code : '';
            // select the finding whether have attachments
            $row['attachments'] = count($result->Evidence) > 0 ? 'Y' : 'N';

            if (is_null($result->nextDueDate)) {
                $row['duetime'] = 'N/A';
            } elseif (date('Ymd', strtotime($result->nextDueDate)) >= date('Ymd', time())) {
                $row['duetime'] = 'On time';
            } else {
                $row['duetime'] = 'Overdue';
            }
            if ($format == 'pdf') {
                $row['systemNickname'] = htmlspecialchars($row['systemNickname']);
                $row['description'] = strip_tags($result->description);
                $row['recommendation'] = strip_tags($result->recommendation);
                $row['mitigationStrategy'] = strip_tags($result->mitigationStrategy);
                $row['threat'] = strip_tags($result->threat);
                $row['countermeasures'] = strip_tags($result->countermeasures);
            } else if ($format == 'xls') {
                $row['description'] = html_entity_decode(strip_tags($result->description));
                $row['recommendation'] = html_entity_decode(strip_tags($result->recommendation));
                $row['mitigationStrategy'] = html_entity_decode(strip_tags($result->mitigationStrategy));
                $row['threat'] = html_entity_decode(strip_tags($result->threat));
                $row['countermeasures'] = html_entity_decode(strip_tags($result->countermeasures));
            } else {
                $row['description'] = $this->view->ShowLongText(
                    strip_tags($result->description), 
                    $this->view->keywords
                );
                $row['recommendation'] = $this->view->ShowLongText(
                    strip_tags($result->recommendation), 
                    $this->view->keywords
                );
                $row['mitigationStrategy'] = $this->view->ShowLongText(
                    strip_tags($result->mitigationStrategy), 
                    $this->view->keywords
                );
                $row['threat'] = $this->view->ShowLongText(strip_tags($result->threat), $this->view->keywords);
                $row['countermeasures'] = $this->view->ShowLongText(
                    strip_tags($result->countermeasures), 
                    $this->view->keywords
                );
            }
            $list[] = $row;
        }
        return $list;
    }
    
    /**
     * Get the vulnerability and assign it to view
     * 
     * @return void
     */
    private function _viewVulnerability()
    {
        $id = $this->_request->getParam('id');
        $vulnerability = $this->_getVulnerability($id);

        // Check that the user is permitted to view this finding
        $this->_acl->requirePrivilegeForObject('read', $vulnerability);

        $this->view->vulnerability = $vulnerability;
    }

    /**
     * Check and get a specified vulnerability
     *
     * @param int $id The specified vulnerability id
     * @return Finding The found vulnerability
     * @throws Fisma_Zend_Exception if the specified vulnerability id is not found
     */
    private function _getVulnerability($id)
    {
        $vulnerability = Doctrine::getTable('Vulnerability')->find($id);

        if (false == $vulnerability) {
             throw new Fisma_Zend_Exception("Vulnerability($id) is not found. Make sure a valid ID is specified.");
        }
        
        return $vulnerability;
    }

    /**
     * Change the state of the current vulnerability
     *
     * @return void
     */
    public function changeStateAction()
    {
        $request = $this->getRequest();

        $id = $request->getParam('id');
        $vulnerability = $this->_getVulnerability($id);

        // The status is sent based on which submit button was clicked
        if ($this->_hasParam('acceptRisk')) {
            $vulnerability->status = 'AR';
        } elseif ($this->_hasParam('falsePositive')) {
            $vulnerability->status = 'FP';
        } elseif ($this->_hasParam('close')) {
            $vulnerability->status = 'CLOSED';
        }

        if ($vulnerability->isModified()) {
            $vulnerability->save();
        }

        $this->_redirect("/vm/vulnerability/view/id/$id");
    }

    /**
     * Display asset
     *
     * @return void
     */
    public function assetAction()
    {
        $this->_viewVulnerability();
        $this->_helper->layout->setLayout('ajax');
    }
}
