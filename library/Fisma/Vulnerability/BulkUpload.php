<?php
/**
 * Copyright (c) 2012 Endeavor Systems, Inc.

 * This file is part of OpenFISMA.
 *
 * OpenFISMA is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OpenFISMA is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with OpenFISMA.  If not, see
 * {@link http://www.gnu.org/licenses/}.
 */

/**
 * It processes bulk uploaded vulnerability scan files.
 *
 * @author     Xue-Wei Tang
 * @copyright  (c) Endeavor Systems, Inc. 2010 {@link http://www.endeavorsystems.com}
 * @license    http://www.openfisma.org/content/license GPLv3
 * @package    Fisma
 * @subpackage Fisma_Vulnerability
 */
require_once(realpath(dirname(__FILE__) . '/FileUpload.php'));

class Fisma_Vulnerability_BulkUpload
{
    /** Directory to unzip the scan files to */
    const BULK_DIR_PATH = "/tmp/vul_bulk_upload";

    private $_userId = null;
    private $_sessionId = null;
    private $_conn = null;

    /**
     * Get all resources used in the class
     */
    private function init()
    {
        $this->_conn = Doctrine_Manager::getInstance()->getCurrentConnection();
        $this->_sessionId = round(microtime(true) * 1000);

        gc_enable();
        ini_set('memory_limit', '1024M');
    }

    /**
     * Import scan result files
     *
     * @return void
     */
    public function process($fileinfo, $userid)
    {
        try {
            $this->init();
            $this->_userId = $userid;

            $user = Doctrine::getTable('User')->find($userid);
            CurrentUser::setInstance($user);

            $this->rrmdir(self::BULK_DIR_PATH);
            mkdir(self::BULK_DIR_PATH, 0777);

            $this->addMessage("Start Bulk Upload",
                              $fileinfo['selectFile'],
                              "Received zip file");

            $dirName = self::BULK_DIR_PATH . "/" . $fileinfo['filename'];

            $zipfile = new ZipArchive;
            $res = $zipfile->open($fileinfo['filepath']);
            if ($res === TRUE) {
                $zipfile->extractTo(self::BULK_DIR_PATH);
                $zipfile->close();
            } else {
                $this->addMessage("End Bulk Upload With Error",
                                  $fileinfo['selectFile'],
                                  "Failed to unzip the file");
                return;
            }

            $fileCount = $this->getFileCount($dirName);
            $this->addMessage("Count File",
                              $fileinfo['selectFile'],
                              "Files to process: " . $fileCount);

            if ($handle = opendir($dirName)) {
                $count = 0;

                // Process each file in the temp directory
                while (false !== ($entry = readdir($handle))) {

                    if ($entry != "." && $entry != "..") {
                        $filePath = $dirName . "/" . $entry;

                        $newfile = $this->arrayClone($fileinfo);
                        $newfile['filepath'] = $dirName . "/" . $entry;
                        $newfile['filename'] = pathinfo(basename($filePath), PATHINFO_FILENAME);
                        $newfile['fileext'] = pathinfo($filePath, PATHINFO_EXTENSION);

                        if ($newfile['fileext'] === "xml") {
                            $newfile['mimetype'] = "application/xml";

                            // Upload this file
                            $this->addMessage(
                                     "Upload File",
                                     $entry,
                                     "Uploading the scan file");

                            $rc = Fisma_Vulnerability_FileUpload::
                                       processFile($newfile, $this->_userId, false);

                            if (isset($rc['uploadId'])) {
                                $rows = $this->addDetailMessage(
                                        "Upload File",
                                        $entry,
                                        "Uploaded the scan file",
                                        $rc['scanType'],
                                        $rc['uploadId']);

                                $count++;

                            } else {
                                $tmp = "";
                                if (!empty($rc['msg'])) {
                                    $tmp = $this->getMessage($rc['msg']);
                                }
                                $this->addMessage(
                                        "Upload File",
                                        $entry,
                                        "Failed to upload the scan file. " . $tmp);
                            }

                        } else {
                            $this->addMessage(
                                     "Check Scan File Format",
                                     $entry,
                                     "It is not a corrct scan file format.");
                            continue;
                        }
                    }
                }

                closedir($handle);

                $this->addMessage(
                        "End Bulk Upload",
                         $entry,
                         ($fileCount == $count) ? "Successful" : "Finished with warnings.");

                $rows = $this->updateVulnerabilityUploadId();

                // Send notification
                $url = "?q=/bulkUploadIds/textContains/" . $this->_sessionId;

                $msgs = $rows['msg'];
                $detail = "";
                switch (count($msgs)) {
                    case 3:
                        $detail = array_shift($msgs) . ', ' . array_shift($msgs) .
                                ', and ' . array_shift($msgs) . ".";
                        break;
                    case 2:
                        $detail = implode(' and ', $msgs) . ".";
                        break;
                    case 1:
                        $detail = $msgs[0] . ".";
                        break;
                }

                Notification::notify("VULNERABILITY_IMPORTED",
                                     null,
                                     CurrentUser::getInstance(),
                                     array('appUrl' => $url,
                                           'rowsProcessed' => $fileCount .
                                               " files processed. " . $rows['total'],
                                           'suppDetail' => $detail));
            } else {
                $this->addMessage("End Bulk Upload With Error"
                                 ,$dirName
                                 ,"Failed to open the directory to read scan files.");
            }
        } catch (Exception $e) {
            $this->addMessage(
                     "End Bulk Upload With Error",
                     "",
                     "Error: " . $e->getMessage());
        }

        $this->rrmdir(self::BULK_DIR_PATH);
    }

    /**
     * Add a meesage record
     * @param string $eventName
     * @param string $fileName
     * @param string $message
     * @param string $scanType
     */
    private function addMessage(
                    $eventName, $fileName, $message, $scanType=null)
    {
        $sql = "INSERT INTO vulnerability_bulk_upload_status (
                  userid, sessionid, eventdt, eventname, filename,
                  scantype, eventmessage
                ) VALUES (?,?,NOW(),?,?,?,?)";

        $q = $this->_conn->prepare($sql);
        $q->execute(array(
                        $this->_userId,
                        $this->_sessionId,
                        $eventName,
                        $fileName,
                        $scanType,
                        $message));
    }

    /**
     * Add a meesage record with upload detail
     * @param string $eventName
     * @param string $fileName
     * @param string $message
     */
    private function addDetailMessage(
                    $eventName, $fileName, $message, $scanType, $uploadId)
    {
        $sql = "INSERT INTO vulnerability_bulk_upload_status (
                  userid, sessionid, eventdt, eventname, filename,
                  scantype, uploadid, eventmessage,
                  creatednum, reopenednum, suppressednum

                ) VALUES (?,?,NOW(),?,?,?,?,?,
                  (SELECT count(*) FROM vulnerability_upload WHERE uploadid=? AND action='CREATE'),
                  (SELECT count(*) FROM vulnerability_upload WHERE uploadid=? AND action='REOPEN'),
                  (SELECT count(*) FROM vulnerability_upload WHERE uploadid=? AND action='SUPPRESS')
                )";

        $q = $this->_conn->prepare($sql);
        $q->execute(array(
                $this->_userId,
                $this->_sessionId,
                $eventName,
                $fileName,
                $scanType,
                $uploadId,
                $message,
                $uploadId,
                $uploadId,
                $uploadId
        ));

        $sqlUpd = "UPDATE vulnerability_upload SET bulkuploadid = ?
                   WHERE uploadid = ? ";

        $qUpd = $this->_conn->prepare($sqlUpd);
        $qUpd->execute(array(
                $this->_sessionId,
                $uploadId)
        );
    }

    /**
     * Updates the vulnerability bulkuploadid.
     * @return array
     */
    private function updateVulnerabilityUploadId()
    {
        $sqlUpd = "UPDATE vulnerability
                      SET bulkuploadids = concat_ws(',',bulkuploadids, ?)
                    WHERE id = ? ";
        $qUpd = $this->_conn->prepare($sqlUpd);

        $sqlVul = "SELECT distinct vulnerabilityid
                     FROM vulnerability_upload
                    WHERE bulkuploadid = ? ";
        $qVul = $this->_conn->prepare($sqlVul);
        $qVul->execute(array($this->_sessionId));

        $count = 0;
        while($r = $qVul->fetch()) {
            $vulId = $r['vulnerabilityid'];
            $qUpd->execute(array($this->_sessionId, $vulId));
            $count++;
        }

        // Get stats
        $sqlVul = "SELECT vulnerabilityid, action
                     FROM vulnerability_upload
                    WHERE bulkuploadid = ? ";
        $qVul = $this->_conn->prepare($sqlVul);
        $qVul->execute(array($this->_sessionId));

        $created = 0;
        $reopened = 0;
        $suppressed = 0;
        while($r = $qVul->fetch()) {
            if ($r['action'] === 'CREATE') {
                $created++;
            } else if ($r['action'] === 'REOPEN') {
                $reopened++;
            } else if ($r['action'] === 'SUPPRESS') {
                $suppressed++;
            }
        }

        // Update the Solr
        Fisma_Vulnerability_FileUpload::rebuildIndex();

        $msg = array();
        if ($created > 1) {
            array_push($msg, $created . " vulnerabilities created");
        } else if ($created > 0) {
            array_push($msg, $created . " vulnerability created");
        }

        if ($reopened > 1) {
            array_push($msg, $reopened . " vulnerabilities reopened");
        } else if ($reopened > 0) {
            array_push($msg, $reopened . " vulnerability reopened");
        }

        if ($suppressed > 1) {
            array_push($msg, $suppressed . " vulnerabilities suppressed");
        } else if ($suppressed > 0) {
            array_push($msg, $suppressed . " vulnerability suppressed");
        }

        return array('total' => $count, 'msg' => $msg);
    }

    /**
     * It deep-clones the given array.
     *
     * @param array $arr
     * @return array
     */
    private function arrayClone($arr)
    {
        foreach ($arr as $key => $value) {

            if(is_array($value)) {
                $newArray[$key] = arrayClone($value);
            } elseif(is_object($value)) {
                $newArray[$key] = clone $value;
            } else {
                $newArray[$key] = $value;
            }
        }
        return $newArray;
    }

    /**
     * Return the file count in the zip file.
     *
     * @param unknown_type $dir
     * @return number
     */
    private function getFileCount($dir)
    {
        $count = 0;
        if ($handle = opendir($dir)) {
            while (false !== ($entry = readdir($handle))) {
                if ($entry != "." && $entry != "..") {
                    $count++;
                }
            }
            closedir($handle);
        }

        return $count;
    }

    /**
     * Flatten the upload message
     *
     * @param array $msg
     * @return string
     */
    private function getMessage($msg)
    {
        $retMsg = "";
        foreach($msg as $key => $value) {
            if (is_array($value) || is_object($value)) {
                $value = "<ul>" . $this->getMessage($value) . "</ul>";
            }

            if (is_array($msg)) {
                if (!stripos($value, "<li")) {
                    $retMsg .= "<li>" . $value . "</li>";
                } else {
                    $retMsg .= $value;
                }
            } else {
                if (!stripos($value, "<li")) {
                    $value = "<ul><li>" . $value . "</li></ul>";
                }

                $retMsg .= "<li>" . $key . $value . "</li>";
            }
        }

        return $retMsg;
    }

    /**
     * Remove a directory and all the files in it.
     * @param $dir
     */
    function rrmdir($dir)
    {
        if (!is_dir($dir)) {
            return;
        }

        foreach(glob($dir . '/*') as $file) {
            if(is_dir($file)) {
                $this->rrmdir($file);
            } else {
                unlink($file);
            }
        }
        rmdir($dir);
    }
}
