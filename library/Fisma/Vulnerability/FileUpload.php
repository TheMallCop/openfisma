<?php
/**
 * Copyright (c) 2012 Endeavor Systems, Inc.
 *
 * This file is part of OpenFISMA.
 *
 * OpenFISMA is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OpenFISMA is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with OpenFISMA.  If not, see
 * {@link http://www.gnu.org/licenses/}.
 */

/**
 * It processes one uploaded vulnerability scan file.
 *
 * @author     Xue-Wei Tang
 * @copyright  (c) Endeavor Systems, Inc. 2010 {@link http://www.endeavorsystems.com}
 * @license    http://www.openfisma.org/content/license GPLv3
 * @package    Fisma
 * @subpackage Fisma_Vulnerability
 */

class Fisma_Vulnerability_FileUpload
{
    /**
     * Process one uploaded vulnerability file
     * @param $fileinfo
     * @param $notify - (true, false) whether to send the notification
     * @throws Fisma_Zend_Exception_InvalidFileFormat
     * @return array
     */
    public static function processFile($fileinfo, $userid, $notify)
    {
        // Execute the plugin with the received file
        $rc = array();

        try {
            $plugin = Fisma_Inject_Factory::create(NULL, $fileinfo);
            $scanType = Fisma_Inject_Factory::detectType($fileinfo['filepath']);

            // organize upload data
            $upload = new Upload();
            $upload->userId = $userid;
            $upload->save();

            // parse the file
            $plugin->parse($upload->id);

            // add the file to storage
            $upload->instantiate(array(
                    'tmp_name' => $fileinfo['filepath'],
                    'name' => $fileinfo['filename'],
                    'type' => $fileinfo['mimetype']
                            ));

            $rows = self::updateVulnerabilityUploadId($upload->id, $notify);

            $msgs[] = $plugin->getMessages();
            if (!empty($msgs)) {
                $rc = array('msg' => $msgs,
                            'uploadId' => $upload->id,
                            'scanType' => $scanType);

                // Create finding injection notification
                if ($notify) {
                    $url = "?q=/uploadIds/textContains/" . $upload->id;

                    $detail = "$rows[total] row(s) processed in 1 file.<br/>";
                    if (!empty($msgs[0])) {
                        foreach ($msgs[0] as $msg) {
                            if (!empty($msg)) {
                                $detail .= $msg['notice'];
                            }
                        }
                    }

                    Notification::notify(
                        "VULNERABILITY_IMPORTED",
                        null,
                        CurrentUser::getInstance(),
                        array(
                            'appUrl' => $url,
                            'suppDetail' => $detail
                        )
                    );
                }
                return $rc;
            }
            return null;
        } catch (Fisma_Zend_Exception_InvalidFileFormat $e) {
            throw $e;
        }
    }

    /**
     * Updates the vulnerability uploadids.
     * @return number
     */
    private static function updateVulnerabilityUploadId($uploadId, $notify)
    {
        $sqlUpd = "UPDATE vulnerability
                      SET uploadids = concat_ws(',',uploadids, ?)
                    WHERE id = ? ";
        $qUpd = Doctrine_Manager::getInstance()->getCurrentConnection()->prepare($sqlUpd);

        $sqlVul = "SELECT vulnerabilityid, action
                     FROM vulnerability_upload
                    WHERE uploadid = ? ";
        $qVul = Doctrine_Manager::getInstance()->getCurrentConnection()->prepare($sqlVul);
        $qVul->execute(array($uploadId));

        $count = 0;
        while ($r = $qVul->fetch()) {
            $vulId = $r['vulnerabilityid'];
            $qUpd->execute(array($uploadId, $vulId));

            $count++;
        }

        // Update the Solr
        if ($notify) {
            self::rebuildIndex();
        }

        return array('total' => $count);
    }

    /**
     * Rebuild a vulnerability index so that the uploadids are searchable
     *
     */
    public static function rebuildIndex()
    {
        $searchEngine = Zend_Registry::get('search_engine');
        $modelName = 'Vulnerability';

        $searchEngine->deleteByType($modelName);

        $indexer = new Fisma_Search_Indexer($searchEngine);
        $allRecordsQuery = $indexer->getRecordFetchQuery($modelName);

        $chunkSize = 100;
        $table = Doctrine::getTable($modelName);

        if ($table instanceof Fisma_Search_CustomChunkSize_Interface) {
            $chunkSize = $table->getIndexChunkSize();
        }

        // Do the actual indexing
        $indexer->indexRecordsFromQuery($allRecordsQuery, $modelName, $chunkSize, null);

        $searchEngine->commit();
    }
}
