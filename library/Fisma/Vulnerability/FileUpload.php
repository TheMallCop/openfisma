<?php
/**
 * Copyright (c) 2012 Endeavor Systems, Inc.

 * This file is part of OpenFISMA.
 *
 * OpenFISMA is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OpenFISMA is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with OpenFISMA.  If not, see
 * {@link http://www.gnu.org/licenses/}.
 */

/**
 * It processes one uploaded vulnerability scan file.
 *
 * @author     Xue-Wei Tang
 * @copyright  (c) Endeavor Systems, Inc. 2010 {@link http://www.endeavorsystems.com}
 * @license    http://www.openfisma.org/content/license GPLv3
 * @package    Fisma
 * @subpackage Fisma_Vulnerability
 */

class Fisma_Vulnerability_FileUpload
{
    /**
     * Process one uploaded vulnerability file
     * @param $fileinfo
     * @param $notify - (true, false) whether to send the notification
     * @throws Fisma_Zend_Exception_InvalidFileFormat
     * @return array
     */
    public static function processFile($fileinfo, $userid, $notify)
    {
        // Execute the plugin with the received file
        $rc = array();

        try {
            $plugin = Fisma_Inject_Factory::create(NULL, $fileinfo);
            $scanType = Fisma_Inject_Factory::detectType($fileinfo['filepath']);

            // organize upload data
            $upload = new Upload();
            $upload->userId = $userid;
            $upload->save();

            // parse the file
            $plugin->parse($upload->id);

            // add the file to storage
            $upload->instantiate(array(
                    'tmp_name' => $fileinfo['filepath'],
                    'name' => $fileinfo['filename'],
                    'type' => $fileinfo['mimetype']
                            ));

            $rows = self::updateVulnerabilityUploadId($upload->id, $notify);

            $msgs[] = $plugin->getMessages();
            if (!empty($msgs)) {
                $rc = array('msg' => $msgs,
                            'uploadId' => $upload->id,
                            'scanType' => $scanType);

                // Create finding injection notification
                if ($notify) {
                    $url = "?q=/uploadIds/textContains/" . $upload->id;

                    $msgs = $rows['msg'];
                    $detail = "";
                    switch (count($msgs)) {
                        case 3:
                            $detail = array_shift($msgs) . ', ' . array_shift($msgs) .
                                      ', and ' . array_shift($msgs) . ".";
                            break;
                        case 2:
                            $detail = implode(' and ', $msgs) . ".";
                            break;
                        case 1:
                            $detail = $msgs[0] . ".";
                            break;
                     }

                     Notification::notify("VULNERABILITY_IMPORTED",
                                          null,
                                          CurrentUser::getInstance(),
                                          array('appUrl' => $url,
                                                'rowsProcessed' => "1 file processed. " . $rows['total'],
                                                'suppDetail' => $detail));
                }

                return $rc;
            }

            return null;
        } catch (Fisma_Zend_Exception_InvalidFileFormat $e) {
            throw $e;
        }
    }

    /**
     * Updates the vulnerability uploadids.
     * @return number
     */
    private static function updateVulnerabilityUploadId($uploadId, $notify)
    {
        $sqlUpd = "UPDATE vulnerability
                      SET uploadids = concat_ws(',',uploadids, ?)
                    WHERE id = ? ";
        $qUpd = Doctrine_Manager::getInstance()->getCurrentConnection()->prepare($sqlUpd);

        $sqlVul = "SELECT vulnerabilityid, action
                     FROM vulnerability_upload
                    WHERE uploadid = ? ";
        $qVul = Doctrine_Manager::getInstance()->getCurrentConnection()->prepare($sqlVul);
        $qVul->execute(array($uploadId));

        $count = 0;
        $created = 0;
        $reopened = 0;
        $suppressed = 0;
        while($r = $qVul->fetch()) {
            $vulId = $r['vulnerabilityid'];
            $qUpd->execute(array($uploadId, $vulId));

            $count++;
            if ($r['action'] === 'CREATE') {
                $created++;
            } else if ($r['action'] === 'REOPEN') {
                $reopened++;
            } else if ($r['action'] === 'SUPPRESS') {
                $suppressed++;
            }
        }

        // Update the Solr
        if ($notify) {
            self::rebuildIndex();
        }

        $msg = array();

        if ($created > 1) {
            array_push($msg, $created . " vulnerabilities created");
        } else if ($created > 0) {
            array_push($msg, $created . " vulnerability created");
        }

        if ($reopened > 1) {
            array_push($msg, $reopened . " vulnerabilities reopened");
        } else if ($reopened > 0) {
            array_push($msg, $reopened . " vulnerability reopened");
        }

        if ($suppressed > 1) {
            array_push($msg, $suppressed . " vulnerabilities suppressed");
        } else if ($suppressed > 0) {
            array_push($msg, $suppressed . " vulnerability suppressed");
        }

        return array('total' => $count, 'msg' => $msg);
    }

    /**
     * Rebuild a vulnerability index so that the uploadids are searchable
     *
     */
    public static function rebuildIndex()
    {
        $searchEngine = Zend_Registry::get('search_engine');
        $modelName = 'Vulnerability';

        $searchEngine->deleteByType($modelName);

        $indexer = new Fisma_Search_Indexer($searchEngine);
        $allRecordsQuery = $indexer->getRecordFetchQuery($modelName);

        $chunkSize = 100;
        $table = Doctrine::getTable($modelName);

        if ($table instanceof Fisma_Search_CustomChunkSize_Interface) {
            $chunkSize = $table->getIndexChunkSize();
        }

        // Do the actual indexing
        $indexer->indexRecordsFromQuery($allRecordsQuery, $modelName, $chunkSize, null);

        $searchEngine->commit();
    }
}
