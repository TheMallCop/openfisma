<?php
/**
 * Copyright (c) 2011 Endeavor Systems, Inc.
 *
 * This file is part of OpenFISMA.
 *
 * OpenFISMA is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OpenFISMA is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with OpenFISMA.  If not, see
 * {@link http://www.gnu.org/licenses/}.
 */

require_once(realpath(dirname(__FILE__) . '/../../../Case/Unit.php'));

/**
 * this test suite was quite meaningless because all assertions require knowledge of
 * internal values defined in the tested class
 *
 * @author     Duy K. Bui <duy.bui@endeavorsystems.com>
 * @copyright  (c) Endeavor Systems, Inc. 2011 {@link http://www.endeavorsystems.com}
 * @license    http://www.openfisma.org/content/license GPLv3
 * @package    Test
 * @subpackage Test_Library
 */
class Test_Library_Fisma_Vulnerability_Cvss extends Test_Case_Unit
{
    /**
     * test setter()'s and getter()'s
     * @return void
     */
    public function testAccessors()
    {
        $cvss = new Fisma_Vulnerability_Cvss();

        $cvss->setAV('L');
        $this->assertEquals(0.395, $cvss->getAV());
        $cvss->setAV('A');
        $this->assertEquals(0.646, $cvss->getAV());
        $cvss->setAV('N');
        $this->assertEquals(1, $cvss->getAV());

        $cvss->setAC('H');
        $this->assertEquals(0.35, $cvss->getAC());
        $cvss->setAC('M');
        $this->assertEquals(0.61, $cvss->getAC());
        $cvss->setAC('L');
        $this->assertEquals(0.71, $cvss->getAC());

        $cvss->setAu('M');
        $this->assertEquals(0.45, $cvss->getAu());
        $cvss->setAu('S');
        $this->assertEquals(0.56, $cvss->getAu());
        $cvss->setAu('N');
        $this->assertEquals(0.704, $cvss->getAu());

        $cvss->setC('N');
        $this->assertEquals(0, $cvss->getC());
        $cvss->setC('P');
        $this->assertEquals(0.275, $cvss->getC());
        $cvss->setC('C');
        $this->assertEquals(0.66, $cvss->getC());

        $cvss->setI('N');
        $this->assertEquals(0, $cvss->getI());
        $cvss->setI('P');
        $this->assertEquals(0.275, $cvss->getI());
        $cvss->setI('C');
        $this->assertEquals(0.66, $cvss->getI());

        $cvss->setA('N');
        $this->assertEquals(0, $cvss->getA());
        $cvss->setA('P');
        $this->assertEquals(0.275, $cvss->getA());
        $cvss->setA('C');
        $this->assertEquals(0.66, $cvss->getA());

        $baseVector = array(
            'AV'    => 'N',
            'AC'    => 'L',
            'Au'    => 'N',
            'C'     => 'C',
            'I'     => 'C',
            'A'     => 'C'
        );
        $this->assertEquals($baseVector, $cvss->getBaseVectorArray());

        $labelVector = array(
            'AV'    => 'Network',
            'AC'    => 'Low',
            'Au'    => 'None',
            'C'     => 'Complete',
            'I'     => 'Complete',
            'A'     => 'Complete'
        );
        $this->assertEquals($labelVector, $cvss->getBaseVectorLabels());

        $cvss->setE('U');
        $this->assertEquals(0.85, $cvss->getE());
        $cvss->setE('POC');
        $this->assertEquals(0.9, $cvss->getE());
        $cvss->setE('F');
        $this->assertEquals(0.95, $cvss->getE());
        $cvss->setE('H');
        $this->assertEquals(1, $cvss->getE());
        $cvss->setE('ND');
        $this->assertEquals(1, $cvss->getE());

        $cvss->setRL('OF');
        $this->assertEquals(0.87, $cvss->getRL());
        $cvss->setRL('TF');
        $this->assertEquals(0.9, $cvss->getRL());
        $cvss->setRL('W');
        $this->assertEquals(0.95, $cvss->getRL());
        $cvss->setRL('U');
        $this->assertEquals(1, $cvss->getRL());
        $cvss->setRL('ND');
        $this->assertEquals(1, $cvss->getRL());

        $cvss->setRC('UC');
        $this->assertEquals(0.9, $cvss->getRC());
        $cvss->setRC('UR');
        $this->assertEquals(0.95, $cvss->getRC());
        $cvss->setRC('C');
        $this->assertEquals(1, $cvss->getRC());
        $cvss->setRC('ND');
        $this->assertEquals(1, $cvss->getRC());

        $temporalVector = array(
            'E'     => 'ND',
            'RL'    => 'ND',
            'RC'    => 'ND'
        );
        $this->assertEquals($temporalVector, $cvss->getTemporalVectorArray());

        $cvss->setCDP('N');
        $this->assertEquals(0, $cvss->getCDP());
        $cvss->setCDP('L');
        $this->assertEquals(0.1, $cvss->getCDP());
        $cvss->setCDP('LM');
        $this->assertEquals(0.3, $cvss->getCDP());
        $cvss->setCDP('MH');
        $this->assertEquals(0.4, $cvss->getCDP());
        $cvss->setCDP('H');
        $this->assertEquals(0.5, $cvss->getCDP());
        $cvss->setCDP('ND');
        $this->assertEquals(0, $cvss->getCDP());

        $cvss->setTD('N');
        $this->assertEquals(0, $cvss->getTD());
        $cvss->setTD('L');
        $this->assertEquals(0.25, $cvss->getTD());
        $cvss->setTD('M');
        $this->assertEquals(0.75, $cvss->getTD());
        $cvss->setTD('H');
        $this->assertEquals(1, $cvss->getTD());
        $cvss->setTD('ND');
        $this->assertEquals(1, $cvss->getTD());
        
        $cvss->setCR('L');
        $this->assertEquals(0.5, $cvss->getCR());
        $cvss->setCR('M');
        $this->assertEquals(1, $cvss->getCR());
        $cvss->setCR('H');
        $this->assertEquals(1.51, $cvss->getCR());
        $cvss->setCR('ND');
        $this->assertEquals(1, $cvss->getCR());

        $cvss->setIR('L');
        $this->assertEquals(0.5, $cvss->getIR());
        $cvss->setIR('M');
        $this->assertEquals(1, $cvss->getIR());
        $cvss->setIR('H');
        $this->assertEquals(1.51, $cvss->getIR());        
        $cvss->setIR('ND');
        $this->assertEquals(1, $cvss->getIR());

        $cvss->setAR('L');
        $this->assertEquals(0.5, $cvss->getAR());
        $cvss->setAR('M');
        $this->assertEquals(1, $cvss->getAR());
        $cvss->setAR('H');
        $this->assertEquals(1.51, $cvss->getAR());
        $cvss->setAR('ND');
        $this->assertEquals(1, $cvss->getAR());

        $environmentalVector = array(
            'CDP'   => 'ND',
            'CD'    => 'ND',
            'TD'    => 'ND',
            'CR'    => 'ND',
            'IR'    => 'ND',
            'AR'    => 'ND',
        );
        $this->assertEquals($environmentalVector, $cvss->getEnvironmentalVectorArray());
    }

    /*
     * test parseVector
     * then with the parsed data, test calculations
     * @return void
     */
    public function testParsingAndCalculation()
    {
        $cvss = new Fisma_Vulnerability_Cvss();

        $this->assertEquals(0, $cvss->parseVector('')); //should have returned false for error
        $cvss->calcEnvironmentalScore();
        $cvss->calcTemporalScore();
        $this->assertEquals('Undefined', $cvss->getEnvironmentalScore());
        $this->assertEquals('Undefined', $cvss->getTemporalScore());

        $vector = 'AV:N/AC:L/Au:N/C:C/I:C/A:C/E:ND/RL:ND/RC:ND/CDP:ND/CD:ND/TD:ND/CR:ND/IR:ND/AR:ND';
        $this->assertEquals(1, $cvss->parseVector($vector)); //should have returned true for success
        $this->assertEquals($vector, $cvss->__tostring());         

        $cvss->calculate();        
        $this->assertEquals(10, $cvss->getBaseScore());
        $this->assertEquals(8.9, $cvss->getAdjustedBaseScore());
        $this->assertEquals(10, $cvss->getImpactScore());
        $this->assertEquals(10, $cvss->getAdjustedImpactScore());
        $this->assertEquals(10, $cvss->getExploitabilityScore());

        $cvss->calcTemporalScore(); //again, with valid data
        $this->assertEquals(10, $cvss->getTemporalScore());
        $this->assertEquals(10, $cvss->getAdjustedTemporalScore());
        
        $cvss->calcEnvironmentalScore(); //again, with valid data
        $this->assertEquals(10, $cvss->getEnvironmentalScore());
    }

    /*
     * the following 14 methods test exceptions thrown for invalid inputs
     * due to phpunit's limitation, each setExpectedException must be done in its own method
     */
    public function testSetAVError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Access Vector');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setAV(null);
    }
    public function testSetACError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Access Complexity');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setAC(null);
    }
    public function testSetAuError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Authentication Values');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setAu(null);
    }
    public function testSetCError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Confidentiality Impact');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setC(null);
    }
    public function testSetIError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Integrity Impact');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setI(null);
    }
    public function testSetAError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Availability Impact');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setA(null);
    }
    public function testSetEError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Exploitability Values');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setE(null);
    }
    public function testSetRLError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Remediation Levels');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setRL(null);
    }
    public function testSetRCError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Report Confidence');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setRC(null);
    }
    public function testSetCDPError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Collateral Damage');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setCDP(null);
    }
    public function testSetTDError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Target Distribution');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setTD(null);
    }
    public function testSetCRError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Confidentiality Requirement');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setCR(null);
    }
    public function testSetARError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Availability Requirement');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setAR(null);
    }
    public function testSetIRError()
    {
        $this->setExpectedException('Fisma_Zend_Exception', 'Failed to set Integrity Requirement');
        $cvss = new Fisma_Vulnerability_Cvss();
        $cvss->setIR(null);
    }
}

